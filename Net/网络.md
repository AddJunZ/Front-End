<!-- 网络.md -->
### http的版本
1. HTTP0.9只支持GET，不支持请求头，只有返回HTML字符串的能力，服务器响应后关闭TCP连接。
2. HTTP1.0增加多种请求方法（POST、DELETE、PUT、HEADER），增加请求头和响应头，可以传输多种数据格式。默认是短连接，每次与服务器交互都需要新建一个连接TCP。前一个请求响应到达之后下一个请求才能发送。
3. HTTP1.1增加多种请求方法（PUT、PATCH、OPTIONS、DELETE），默认使用持久化连接（Connection:keep-alive），多次请求由一个tcp连接完成，当并发多个请求需要多个TCP连接，每次TCP连接都需要三次握手四次挥手，浏览器为了控制资源会有6-8个TCP连接限制（chrome为6）。
4. HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。同域名下所有通信都在单个连接上完成，消除了因多个TCP连接而带来的延时和内存消耗；单个连接上可以并行交错的请求和响应，之间互不干扰，同一时刻可以传输多个HTTP请求。允许服务端推送。

### http2.0的流和帧的概念
二进制协议将通信数据分解为更小的帧，数据帧在C/S的双向数据流中不断运输。

二进制分帧的几个概念（前面包含多个后面的）
1. 链接Link：指的是一条C/S之间的TCP链接
2. 数据流Stream：已建立的TCP连接的双向字节流，TCP中可以有一条或者多条消息
3. 消息Message：消息属于一个数据流，消息就是逻辑请求或响应消息对应的完整的一系列帧，也就是帧组成了消息
4. 帧Frame：帧是通信的最小单位，每个真都包含帧头和消息体，标识出当前帧所属的数据流（帧中有流标识符）


### cookie、session和token的区别
1. cookie储存在客户端，最大长度不超过4KB。
2. session储存在服务器（运用加密算法），客户端只需要储存 sessionId 就可以维持登录状态，客户端在 cookies 中携带 sessionId，访问登录接口，获得用户信息。服务端检查 sessionId 合法性，以及是否过期，但是耗费服务端性能。优点:速度快，安全；缺点：服务器是有状态的。多台后端服务器无法共享 session。解决方法是，专门准备一台 session 服务器，关于 session 的所有操作都交给它来调用
3. token，服务器不需要存储Session状态

### dns解析过程(m.xyz.com 查 y.abc.com)
1. 迭代查询

主机(m.xyz.com) -> **本地DNS服务器**(dns.xyz.com) -> 根域名DNS服务器 -> 顶级域名服务器(dns.com) -> 权限域名服务器(dns.abc.com) -(IP)-> **本地DNS服务器** -(IP)-> 主机

2. 递归查询

主机(m.xyz.com) -> **本地DNS服务器**(dns.xyz.com) -> 根域名DNS服务器 -> 顶级域名服务器(dns.com) -> 权限域名服务器(dns.abc.com) -(IP)-> 顶级域名服务器 -(IP)-> 根域名DNS服务器 -(IP)-> **本地DNS服务器** -(IP)-> 主机

### CDN原理
网络请求直接访问源服务器比较费时，通过cdn把源站的内容缓存到多个服务节点，用户访问时就向最近的站点请求响应。

具体步骤：

1. 用户向(www.test.com)请求图片资源
2. 向Local DNS请求域名解析
3. 解析www.test.com时，发现其配置了CNAME（别名），解析请求就会发送到对应的云平台的DNS服务器上
4. Local DNS获取云平台DNS服务器返回的解析IP
5. 用户获取解析IP，发起对图片资源的请求
6. 若该IP对应节点有缓存该资源则直接返回，没有则需要向源服务站点发起对该资源的请求
7. 获取该资源后，该IP站点会根据缓存策略进行缓存，并返回给用户

### 跨域的解决方案
1. jsonp（只支持GET）
```js
// 原理是在前端创建script标签，通过script不会被同源策略影响来实现访问
function search(value){
  // 将前端的回调函数返回给后端，后端返回带有参数的fn函数
  jsonp(`http://www.baidu.com/...cb=fn`);
}
function jsonp(url){
  var ele = document.createElement('script');
  ele.setAttribute('src', url);
  document.getElementsByTagName('head')[0].appendChild(ele);
}

function fn(res){
  // 前端写好的逻辑
}
```
2. cors（Cross-origin resource sharing 跨站资源共享）
```js
'Access-Control-Allow-Headers' : '允许的Content-Type'
'Access-Control-Allow-Methods' : '允许的请求方法'
'Access-Control-Allow-headers' : '预请求允许其他方法和类型传输的时间'
```
3. hash
4. postMessage
5. WebSoket
6. http-proxy
```
// vue框架的vue.config.js的proxyTable
```


### OPTIONS方法
1. 产生的条件：
    1. 必须是跨域请求
    2. 自定了请求头
    3. 请求头中的content-type是```application / x - www - form -urlencoded```，```text / plain```，```multipart / form-data```之外的格式


2. 作用
    1. 请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用来代替资源名称，向服务器发送 OPTIONS 请求
    2. 可以测试服务器功能是否正常。