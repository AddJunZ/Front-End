### 设计模式

1. 借鉴参考
> 思路整体参考 github ：huyaocode

2. 全局安装```ts-node```，可以直接允许ts代码无需转化为js文件
```js
// 比如 运行单例模式的代码 命令行
ts-node index.ts
```

### 1. 单例模式
单例模式要求，所有同个类实例化出来的对象，都指向同一个实例。

> 又分为两种，一个是饿汉模式，一种是懒汉模式。区别：初始实例化公共实例对象的时间位置不同。

1. 饿汉模式：直接在类中先实例好公共实例对象，每次调用类获取实例方法的时候读取同一个实例。
2. 懒汉模式：在获取类实例方法的时候再进行实例存在性判断，存在则直接返回，不存在则实例化公共实例对象。

### 2. 原型模式
原型模式跟使用类实例化对象不同，它是同个找到原型上的一个共同的“模板祖先对象”，然后再多次克隆生成多个子对象出来。

这样可以不知道具体的类名，只需要沿着原型找就好了，所有子对象都要有途径找到原型对象。

### 3. 外观模式
隐藏系统的复杂性，并向客户端提供一个简单的接口。本质是对自己系统的多个操作做一个封装，将带有一定逻辑序列的一组操作的接口提供给外部调用。

### 4. 原型模式
js本身就是基于原型链的，这很好理解

### 5. 观察者模式
> [发布订阅与观察者的区别](https://juejin.cn/post/6844903686737494030)
首先观察者（Observer）是带有**update**（更新函数）的类实体。被观察者（Subject）则需要维护一个列表**list**用来维护所有的观察者，有一个**attach**（绑定函数）抛出用来绑定对应的观察者，当被观察者更新状态后，会遍历观察者列表，触发他们每个的**update**函数，并将某些信息发送出去。

### 6. 发布订阅模式
相比观察者，发布订阅增加了一个中介（```Dep```）作为消息的转发。可以通过让```Pub```（发布者）设置多个```Dep```，```Dep```设置多个```Sub```（订阅者）。观察者模式维护的是一个单一事件对应多个依赖这个事件的对象之间关系```event->[obj1,obj2obj3,....]```，订阅发布模式维护的是多个主题(事件) 以及依赖于各个主题(事件)的对象之间的关系```
 event1->[obj1,obj2....],
 event2->[obj1,obj2.....],....```。
