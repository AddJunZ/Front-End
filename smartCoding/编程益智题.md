<!-- 编程益智题.md -->
# 编程益智题
### reduce实现map
根据原数组建立新数组并返回，初始数组是acc并有reduce的第二个参数传入
```js
//map的实现
var arr = [1,2,3];
arr = arr.map(x=>x*2);
console.log(arr);//[2,4,6];

//reduce的实现
reduce(()=>{},[])//第二个参数默认是acc的初始值
let fn = (x)=>{return x * 2};
//实现1
arr = arr.reduce((acc,curr,idx,arr)=>{acc.push(fn(curr));return acc},[])
//实现2
arr = arr.reduce((acc,curr,idx,arr)=>return [...acc,fn(curr)],[]);
```

### charAt和直接用字符串下标的区别
1. 当索引超出字符串有效位置时，前者为空，后者为undefined
2. charAt是字符串的操作，而下标为数组和字符串皆可

### 手写Promise封装ajax
```js

```

### 二维数组去重
```js
// 法一：es6
let res=new Map();
arr.forEach(item=>{
  item.sort((a,b)=>a-b);
  res.set(item.join(),item);
});        
return Array.from(res.values);

// 法二：
let res={}
arr.forEach(item=>{
  item.sort((a,b)=>a-b);
  res[item]=item;
});
return Object.values(res)
```

### 是否有堆栈溢出错误
没有，因为当执行foo时，遇到```setTimeout```等异步代码，就会递交给```Web API```中，当事件触发时，回调函数就会堆积在任务队列中。当事件循环检测到调用堆栈为空时，就会把回调函数放入调用堆栈中进行执行。因为本题函数foo执行完后调用堆栈就为空了，于是不会造成堆栈溢出。
```js
function foo() {
  setTimeout(foo, 0);
};
```

