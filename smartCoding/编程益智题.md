<!-- 编程益智题.md -->
# 编程益智题
### reduce实现map
根据原数组建立新数组并返回，初始数组是acc并有reduce的第二个参数传入
```js
//map的实现
var arr = [1,2,3];
arr = arr.map(x=>x*2);
console.log(arr);//[2,4,6];

//reduce的实现
reduce(()=>{},[])//第二个参数默认是acc的初始值
let fn = (x)=>{return x * 2};
//实现1
arr = arr.reduce((acc,curr,idx,arr)=>{acc.push(fn(curr));return acc},[])
arr = arr.reduce((acc,curr,idx,arr)=>((acc.push(fn(curr))),acc),[])
//实现2
arr = arr.reduce((acc,curr,idx,arr)=>return [...acc,fn(curr)],[]);
arr = arr.reduce((acc,curr,idx,arr)=>[...acc,fn(curr)],[]);
```

### charAt和直接用字符串下标的区别
1. 当索引超出字符串有效位置时，前者为空，后者为undefined
2. charAt是字符串的操作，而下标为数组和字符串皆可


### 二维数组去重
```js
// 法一：es6
let res=new Map();
arr.forEach(item=>{
  item.sort((a,b)=>a-b);
  res.set(item.join(),item);
});        
return Array.from(res.values);

// 法二：
let res={}
arr.forEach(item=>{
  item.sort((a,b)=>a-b);
  res[item]=item;
});
return Object.values(res)
```

### 是否有堆栈溢出错误
没有，因为当执行foo时，遇到```setTimeout```等异步代码，就会递交给```Web API```中，当事件触发时，回调函数就会堆积在任务队列中。当事件循环检测到调用堆栈为空时，就会把回调函数放入调用堆栈中进行执行。因为本题函数foo执行完后调用堆栈就为空了，于是不会造成堆栈溢出。
```js
function foo() {
  setTimeout(foo, 0);
};
```

### 扑克牌
有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；问：原来那堆牌的顺序，用函数实现。
```js
function reverse(arr) {
  let i = 1
  let out = []
  while (arr.length) {
    if (i % 2) {
      out.unshift(arr.pop())
    } else {
      out.unshift(out.pop())
    }
    i++
  }
  return out
}

reverse([1,2,3,4,5,6,7,8,9,10,11,12,13 ])
// [1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]
```

### 树
如何将 [{id: 1}, {id: 2, pId: 1}, ...] 的重复数组（有重复数据）转成树形结构的数组 [{id: 1, child: [{id: 2, pId: 1}]}, ...] （需要去重）
```js
const fn = arr => {
  const res = [];
  const map = arr.reduce((res,item)=>{
    res[item.id] = Object.assign({},item)
    return res;
  },{});
  for(let item of Object.values(map)){
    if(!item.pId){
      res.push(item)
    }else{
      const parent = map[item.pId];
      parent.child = parent.child || [];
      parent.push(item);
    }
  }
  return res;
}
```
