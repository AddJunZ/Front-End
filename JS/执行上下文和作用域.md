## 执行上下文和作用域

### 1. 代码执行前的准备工作（加载程序时确定上下文，对于函数则是在调用的时候确定上下文的）
> 全局代码的执行上下文
1. 变量，函数表达式 ==> 变量声明，默认为undefined
2. this ==> 赋值
3. 函数声明 ==> 赋值
> 代码段是函数体附加的，每次调用函数都会生成一个新的执行上下文
4. arguments ==> 赋值
5. 自由变量的取之作用域 ==> 赋值

### 2. 函数在定义时，就确定了函数体内部自由变量的作用域
```js
var a = 10;
function fn() {
  console.log(a)
}
function fn2(f) {
  var a = 20;
  f();
}
fn2(fn); // 10
```

### 3. 执行上下文
执行全局代码会产生一个执行上下文，每次调用函数又会产生新的执行上下文，这是一个**入栈**的过程。函数执行完后，属于函数的执行上下文被弹出（销毁）。

这里就要引出**闭包**的概念。本来函数执行完成就要销毁自身执行上下文，但如果函数内部返回了一个函数。而这个内部函数又用到了外部函数的自由变量的时候，由于**静态作用域**的原因，内部函数使用的是定义时确定的父级作用域的变量，导致外部函数就不能销毁自身的执行上下文，从而容易导致内存泄露。

### 4. （静态）作用域
- js除了全局作用域之外，只有函数可以创建作用域
- 当本作用域中没有想要的自由变量，就会**到创建这个函数的作用域**中取值，是**创建**而不是调用。这就是所谓的**静态作用域**