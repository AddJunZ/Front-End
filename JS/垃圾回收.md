## 垃圾回收
> 所有的JS对象都是通过堆来进行分配的。

### 1. 如何判断回收内容
**一个对象为活对象当且仅当它被一个根对象或另一个活对象指向**。根对象永远是活对象，被局部变量所指向的对象也属于根对象，因为它在它所在作用域内也被视为根对象。全局对象（Node中的global，浏览器中的window）自然是根对象。浏览器中的DOM也属于根对象。

### 2. V8回收策略
新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长的常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当**新生代**中的对象满足某些条件就会被移动到**老生代**里面。

### 3. 新生代算法（空间较小，更新频繁）
> Scavenge算法 (打扫)

在新生代空间中，内存分为两部分，分别为**from**和**to**空间。在这两个空间中，必定有一个空间是使用的，另一个是空闲的。分配的对象会被放入**from**空间中，当**from**空间被占满后，新生代GC就会启动。算法会检测**from**空间中存活的对象并复制到**to**空间中，如果有失活的对象就会销毁。当复制完成后将**from**空间和**to**空间互换，这样GC就结束了。

### 4， 老生代算法
老生代的对象一般存活时间较长且数量也多，使用两个算法，分别是**标记清除算法**和**标记压缩(整理)算法**。
> 标记清除: 遍历堆中的所有对象，标记活着的休息，在清除阶段清除所有没有被标记的对象，缺点是在内存空间中会出现不连续的状态
> 标记压缩（整理）: 区别是在

> Q: 什么情况下对象会出现在老生代空间中
> A: 1. 新生代中的对象是否已经经历过一次**Scavenge**算法，如果是，则将对象从新生代空间转移到老生代空间中。
> A: 2. **to**空间的对象占比大小超过**25%**，在这种情况下，为了不影响内存分配，会将对象从新生化空间转移到老生代空间中。

### 5. 什么是内存泄漏
内存泄露是指程序中已分配的堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等后果。

### 6. 常见的内存泄露场景
1. 缓存
2. 使用闭包，作用域未释放
3. 没有使用到的全局变量
4. 未清除的定时器
5. 事件监听没有监听的回调函数

### 7. 内存泄漏优化
1. 业务不需要的内部函数结构到函数外部避免产生闭包
2. 清除定时器和事件监听器
3. nodejs中使用stream和buffer来操作大文件，使用堆外内存，不会收nodejs内存限制